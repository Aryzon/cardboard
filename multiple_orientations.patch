From 448d46f8a1e7e6bce74fb2e03cad993d49800ec7 Mon Sep 17 00:00:00 2001
From: maartenslaa <maartenslaa@me.com>
Date: Fri, 12 Feb 2021 15:27:57 +0100
Subject: [PATCH] Muliple orientation support

---
 sdk/head_tracker.cc                           | 47 ++++++-----
 sdk/head_tracker.h                            |  6 ++
 sdk/screen_params.h                           | 10 +++
 .../sdk/screenparams/ScreenParamsUtils.java   | 83 +++++++++++++++++++
 sdk/screen_params/android/screen_params.cc    | 26 ++++++
 sdk/screen_params/ios/screen_params.mm        | 74 +++++++++++++++++
 6 files changed, 227 insertions(+), 19 deletions(-)

diff --git a/sdk/head_tracker.cc b/sdk/head_tracker.cc
index 22318df..81bc6c6 100644
--- a/sdk/head_tracker.cc
+++ b/sdk/head_tracker.cc
@@ -28,7 +28,8 @@ HeadTracker::HeadTracker()
       sensor_fusion_(new SensorFusionEkf()),
       latest_gyroscope_data_({0, 0, Vector3::Zero()}),
       accel_sensor_(new SensorEventProducer<AccelerometerData>()),
-      gyro_sensor_(new SensorEventProducer<GyroscopeData>()) {
+      gyro_sensor_(new SensorEventProducer<GyroscopeData>(),
+      start_orientation_(screen_params::getScreenOrientation()) { // Aryzon multiple orientations
   sensor_fusion_->SetBiasEstimationEnabled(/*kGyroBiasEstimationEnabled*/ true);
   on_accel_callback_ = [&](const AccelerometerData& event) {
     OnAccelerometerData(event);
@@ -36,6 +37,16 @@ HeadTracker::HeadTracker()
   on_gyro_callback_ = [&](const GyroscopeData& event) {
     OnGyroscopeData(event);
   };
+          
+  // Aryzon multiple orientations
+  if (start_orientation_ == screen_params::LandscapeLeft) {
+      ekf_to_head_tracker = Rotation::FromYawPitchRoll(-M_PI / 2.0, 0, -M_PI / 2.0);
+  } else if (start_orientation_ == screen_params::LandscapeRight) {
+      ekf_to_head_tracker = Rotation::FromYawPitchRoll(M_PI / 2.0, 0, M_PI / 2.0);
+  } else {
+      // Portrait
+      ekf_to_head_tracker = Rotation::FromYawPitchRoll(M_PI / 2.0, M_PI / 2.0, M_PI / 2.0);
+  }
 }
 
 HeadTracker::~HeadTracker() { UnregisterCallbacks(); }
@@ -67,29 +78,27 @@ void HeadTracker::GetPose(int64_t timestamp_ns,
                           std::array<float, 4>& out_orientation) const {
   Rotation predicted_rotation;
   const PoseState pose_state = sensor_fusion_->GetLatestPoseState();
-  if (!sensor_fusion_->IsFullyInitialized()) {
-    CARDBOARD_LOGI(
-        "Head Tracker not fully initialized yet. Using pose prediction only.");
-    predicted_rotation = pose_prediction::PredictPose(timestamp_ns, pose_state);
-  } else {
-    predicted_rotation = pose_state.sensor_from_start_rotation;
-  }
+  predicted_rotation = pose_prediction::PredictPose(timestamp_ns, pose_state);
 
   // In order to update our pose as the sensor changes, we begin with the
   // inverse default orientation (the orientation returned by a reset sensor),
   // apply the current sensor transformation, and then transform into display
   // space.
-  // TODO(b/135488467): Support different screen orientations.
-  const Rotation ekf_to_head_tracker =
-      Rotation::FromYawPitchRoll(-M_PI / 2.0, 0, -M_PI / 2.0);
-  const Rotation sensor_to_display =
-      Rotation::FromAxisAndAngle(Vector3(0, 0, 1), M_PI / 2.0);
-
-  const Vector4 q =
-      (sensor_to_display * predicted_rotation * ekf_to_head_tracker)
-          .GetQuaternion();
-  Rotation rotation;
-  rotation.SetQuaternion(q);
+  Rotation sensor_to_display;
+
+  // Aryzon multiple orientations
+  // Very fast implementation on iOS, pretty fast for Android
+  screen_params::ScreenOrientation orientation = screen_params::getScreenOrientation();
+
+  if (orientation == screen_params::LandscapeLeft) {
+      sensor_to_display = Rotation::FromAxisAndAngle(Vector3(0, 0, 1), M_PI / 2.0);
+  } else  if (orientation == screen_params::LandscapeRight) {
+      sensor_to_display = Rotation::FromAxisAndAngle(Vector3(0, 0, 1), -M_PI / 2.0);
+  } else { // Portrait
+      sensor_to_display = Rotation::FromAxisAndAngle(Vector3(0, 0, 1), 0.0);
+  }
+ 
+  Rotation rotation = sensor_to_display * predicted_rotation * ekf_to_head_tracker;
 
   out_orientation[0] = static_cast<float>(rotation.GetQuaternion()[0]);
   out_orientation[1] = static_cast<float>(rotation.GetQuaternion()[1]);
diff --git a/sdk/head_tracker.h b/sdk/head_tracker.h
index 3ba66ca..6db799a 100644
--- a/sdk/head_tracker.h
+++ b/sdk/head_tracker.h
@@ -26,6 +26,9 @@
 #include "sensors/sensor_fusion_ekf.h"
 #include "util/rotation.h"
 
+// Aryzon multiple orientations
+#include "screen_params.h"
+
 namespace cardboard {
 
 // HeadTracker encapsulates pose tracking by connecting sensors
@@ -83,6 +86,9 @@ class HeadTracker {
   // Callback functions registered to the input SingleTypeEventProducer.
   std::function<void(AccelerometerData)> on_accel_callback_;
   std::function<void(GyroscopeData)> on_gyro_callback_;
+    
+  // Aryzon multiple orientations
+  const screen_params::ScreenOrientation start_orientation_;
 };
 
 }  // namespace cardboard
diff --git a/sdk/screen_params.h b/sdk/screen_params.h
index 5ab0240..94899b1 100644
--- a/sdk/screen_params.h
+++ b/sdk/screen_params.h
@@ -28,6 +28,16 @@ void initializeAndroid(JavaVM* vm, jobject context);
 #endif
 void getScreenSizeInMeters(int width_pixels, int height_pixels,
                            float* out_width_meters, float* out_height_meters);
+
+// Aryzon multiple orientations
+enum ScreenOrientation {
+    LandscapeLeft,
+    Portrait,
+    LandscapeRight,
+    PortraitUpsideDown
+};
+ScreenOrientation getScreenOrientation();
+
 }  // namespace screen_params
 }  // namespace cardboard
 
diff --git a/sdk/screen_params/android/java/com/google/cardboard/sdk/screenparams/ScreenParamsUtils.java b/sdk/screen_params/android/java/com/google/cardboard/sdk/screenparams/ScreenParamsUtils.java
index ba30dbd..4d44c68 100644
--- a/sdk/screen_params/android/java/com/google/cardboard/sdk/screenparams/ScreenParamsUtils.java
+++ b/sdk/screen_params/android/java/com/google/cardboard/sdk/screenparams/ScreenParamsUtils.java
@@ -21,6 +21,13 @@ import android.os.Build.VERSION_CODES;
 import android.util.DisplayMetrics;
 import android.view.WindowManager;
 
+// Aryzon multiple orientations
+import android.content.res.Configuration;
+import android.hardware.SensorManager;
+import android.view.Display;
+import android.view.OrientationEventListener;
+import android.view.Surface;
+
 /** Utility methods to manage the screen parameters. */
 public abstract class ScreenParamsUtils {
   /** Holds the screen pixel density. */
@@ -68,4 +75,80 @@ public abstract class ScreenParamsUtils {
     }
     return new ScreenPixelDensity(displayMetrics.xdpi, displayMetrics.ydpi);
   }
+    
+    // Aryzon multiple orientations
+    public static class ScreenOrientation {
+      /**
+       * The screen orientation
+       * 0 = lanscape left
+       * 1 = portrait
+       * 2 = landscape right
+       * 3 = portrait upside-down
+       */
+      public static Context context;
+      public static int orientation;
+      public static int previousOrientation;
+      public static OrientationEventListener orientationEventListener;
+
+      public ScreenOrientation(final Context context) {
+        this.context = context;
+        this.orientation = CurrentOrientation(context);
+
+        this.orientationEventListener = new OrientationEventListener(context, SensorManager.SENSOR_DELAY_UI) {
+          public void onOrientationChanged(int orientation_) {
+
+            int newOrientation = context.getResources().getConfiguration().orientation;
+
+            if (orientation_ != ORIENTATION_UNKNOWN && previousOrientation != newOrientation) {
+              orientation = CurrentOrientation(ScreenOrientation.context);
+              previousOrientation = newOrientation;
+            }
+          }
+        };
+        if (this.orientationEventListener.canDetectOrientation()) {
+          this.orientationEventListener.enable();
+        }
+      }
+    }
+
+    private static ScreenOrientation screenOrientation;
+    
+    public static int getScreenOrientation(Context context) {
+      if (screenOrientation == null) {
+
+        screenOrientation = new ScreenOrientation(context);
+      }
+      return screenOrientation.orientation;
+
+    }
+
+    private static int CurrentOrientation (Context context) {
+      if (defaultDisplay == null) {
+        WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
+        defaultDisplay = windowManager.getDefaultDisplay();
+      }
+
+      int orientation = context.getResources().getConfiguration().orientation;
+      // This call takes a long time so we don't call this every frame, only when rotation changes
+      int rotation = defaultDisplay.getRotation();
+
+      if (orientation == Configuration.ORIENTATION_LANDSCAPE
+              &&  (rotation == Surface.ROTATION_0
+              ||  rotation == Surface.ROTATION_90)) {
+        return 0;
+      } else if (orientation == Configuration.ORIENTATION_PORTRAIT
+              &&  (rotation == Surface.ROTATION_0
+              ||  rotation == Surface.ROTATION_90)) {
+        return 1;
+      } else if (orientation == Configuration.ORIENTATION_LANDSCAPE
+              &&  (rotation == Surface.ROTATION_180
+              ||  rotation == Surface.ROTATION_270)) {
+        return 2;
+      } else if (orientation == Configuration.ORIENTATION_PORTRAIT
+              &&  (rotation == Surface.ROTATION_180
+              ||  rotation == Surface.ROTATION_270)) {
+        return 3;
+      }
+      return 3;
+    }
 }
diff --git a/sdk/screen_params/android/screen_params.cc b/sdk/screen_params/android/screen_params.cc
index fad79ef..6272883 100644
--- a/sdk/screen_params/android/screen_params.cc
+++ b/sdk/screen_params/android/screen_params.cc
@@ -29,6 +29,10 @@ jobject context_;
 jclass screen_pixel_density_class_;
 jclass screen_params_utils_class_;
 
+// Aryzon multiple orientations
+jclass screen_orientation_class_;
+jmethodID get_screen_orientation_method;
+
 struct DisplayMetrics {
   float xdpi;
   float ydpi;
@@ -41,6 +45,16 @@ void LoadJNIResources(JNIEnv* env) {
       cardboard::jni::LoadJClass(env,
                                  "com/google/cardboard/sdk/screenparams/"
                                  "ScreenParamsUtils$ScreenPixelDensity");
+    
+  // Aryzon multiple orientations
+  screen_orientation_class_ =
+      cardboard::jni::LoadJClass(env,
+                                 "com/google/cardboard/sdk/screenparams/"
+                                 "ScreenParamsUtils$ScreenOrientation");
+
+  get_screen_orientation_method = env->GetStaticMethodID(screen_params_utils_class_,
+                                                         "getScreenOrientation",
+                                                         "(Landroid/content/Context;)I");
 }
 
 DisplayMetrics getDisplayMetrics() {
@@ -82,5 +96,17 @@ void getScreenSizeInMeters(int width_pixels, int height_pixels,
   *out_height_meters = (height_pixels / display_metrics.ydpi) * kMetersPerInch;
 }
 
+// Aryzon multiple orientations
+ScreenOrientation getScreenOrientation() {
+
+  JNIEnv* env;
+  cardboard::jni::LoadJNIEnv(vm_, &env);
+
+  int screen_orientation = env->CallStaticIntMethod(
+          screen_params_utils_class_, get_screen_orientation_method, context_);
+
+  return (ScreenOrientation)screen_orientation;
+}
+
 }  // namespace screen_params
 }  // namespace cardboard
diff --git a/sdk/screen_params/ios/screen_params.mm b/sdk/screen_params/ios/screen_params.mm
index 1ecfe80..105f0b2 100644
--- a/sdk/screen_params/ios/screen_params.mm
+++ b/sdk/screen_params/ios/screen_params.mm
@@ -18,6 +18,74 @@
 #import <UIKit/UIKit.h>
 #import <sys/utsname.h>
 
+// Aryzon multiple orientations
+@interface OrientationHelper : NSObject {
+    
+}
+@property cardboard::screen_params::ScreenOrientation orientation;
+-(void) orientationChanged:(NSNotification *)note;
+@end
+
+@implementation OrientationHelper {
+    
+}
+@synthesize orientation;
+
+-(id)init
+{
+    self = [super init];
+    if (self) {
+        UIDevice *device = [UIDevice currentDevice];
+        [self setOrientationValue:device];
+        [device beginGeneratingDeviceOrientationNotifications];
+        
+        [[NSNotificationCenter defaultCenter]
+           addObserver:self selector:@selector(orientationChanged:)
+           name:UIDeviceOrientationDidChangeNotification
+           object:device];
+    }
+    return self;
+}
+
+-(void) orientationChanged:(NSNotification *)note {
+    [self setOrientationValue:note.object];
+}
+
+-(void)setOrientationValue:(UIDevice *)device {
+    UIDeviceOrientation orientation = [device orientation];
+    
+    if (!UIDeviceOrientationIsValidInterfaceOrientation(orientation)) {
+        return;
+    }
+    UIInterfaceOrientationMask supportedInterfaces = -1;
+    for (UIWindow *window in [[UIApplication sharedApplication] windows]) {
+        if (!window.hidden && window.subviews.count > 0) {
+            for (int i=0;i<window.subviews.count;i++) {
+                UIView *view = window.subviews[window.subviews.count - 1 - i];
+                if (!view.isHidden && window.rootViewController) {
+                    if (window.rootViewController.shouldAutorotate) {
+                        supportedInterfaces = window.rootViewController.supportedInterfaceOrientations;
+                        break;
+                    }
+                }
+            }
+            break;
+        }
+    }
+    
+    if (orientation == UIDeviceOrientationPortrait && (supportedInterfaces & UIInterfaceOrientationMaskPortrait) != 0) {
+        NSLog(@"Setting portrait");
+        self.orientation = cardboard::screen_params::Portrait;
+    } else if (orientation == UIDeviceOrientationLandscapeLeft && (supportedInterfaces & UIInterfaceOrientationMaskLandscapeRight) != 0) {
+        NSLog(@"Setting landscapeleft");
+        self.orientation = cardboard::screen_params::LandscapeLeft;
+    } else if (orientation == UIDeviceOrientationLandscapeRight && (supportedInterfaces & UIInterfaceOrientationMaskLandscapeLeft) != 0) {
+        NSLog(@"Setting landscaperight");
+        self.orientation = cardboard::screen_params::LandscapeRight;
+    }
+}
+@end
+
 namespace cardboard {
 namespace screen_params {
 
@@ -64,6 +132,12 @@
 static CGFloat const kIPhone12MiniDpi = 476.0f;
 static CGFloat const kIPhone12Dpi = 460.0f;
 
+static OrientationHelper *helper = [[OrientationHelper alloc] init];
+
+ScreenOrientation getScreenOrientation() {
+    return [helper orientation];
+}
+
 CGFloat getDpi() {
   // Gets model name.
   struct utsname systemInfo;
-- 
2.24.3 (Apple Git-128)

